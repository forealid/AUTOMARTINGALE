<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SignalR WebSocket Protocol Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #4CAF50;
            margin-bottom: 30px;
        }

        .connection-panel {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #444;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #ccc;
        }

        input {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
        }

        input::placeholder {
            color: #888;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
        }

        .connect-btn {
            background: #4CAF50;
            color: white;
        }

        .connect-btn:hover {
            background: #45a049;
        }

        .connect-btn.disconnect {
            background: #f44336;
        }

        .connect-btn.disconnect:hover {
            background: #da190b;
        }

        .test-btn {
            background: #2196F3;
            color: white;
        }

        .test-btn:hover {
            background: #0b7dda;
        }

        .clear-btn {
            background: #ff9800;
            color: white;
        }

        .clear-btn:hover {
            background: #e68900;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
        }

        .status-indicator.connected {
            background: #4CAF50;
        }

        .status-indicator.connecting {
            background: #ff9800;
        }

        .data-panel {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #444;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #555;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #4CAF50;
        }

        .crash-history {
            margin-bottom: 20px;
        }

        .crash-values {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .crash-value {
            background: #4CAF50;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .log-container {
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 8px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .log-entry {
            padding: 8px 12px;
            border-bottom: 1px solid #333;
            word-wrap: break-word;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.info {
            color: #2196F3;
        }

        .log-entry.success {
            color: #4CAF50;
        }

        .log-entry.warning {
            color: #ff9800;
        }

        .log-entry.error {
            color: #f44336;
        }

        .log-entry.crash {
            color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            font-weight: 600;
        }

        .log-entry.history {
            color: #9C27B0;
            background: rgba(156, 39, 176, 0.1);
        }

        .timestamp {
            color: #666;
            font-size: 11px;
        }

        .educational-note {
            background: #2d2d2d;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
        }

        .educational-note h3 {
            margin: 0 0 10px 0;
            color: #2196F3;
        }

        .frame-structure {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 10px;
            border: 1px solid #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SignalR WebSocket Protocol Demo</h1>
        
        <div class="educational-note">
            <h3>Educational Purpose</h3>
            <p>This demo demonstrates how SignalR protocol works over WebSockets, including:</p>
            <ul>
                <li>Frame separation using \u001e delimiter</li>
                <li>JSON message parsing and structure</li>
                <li>Protocol handshake and hub invocations</li>
                <li>Message type handling (OnCrash, OnRegistration, etc.)</li>
            </ul>
            <div class="frame-structure">
                SignalR Frame Structure:<br>
                {"protocol":"json","version":1}\u001e (handshake)<br>
                {"arguments":[...],"invocationId":"1","target":"Hub","type":1}\u001e (invoke)<br>
                {"type":1,"target":"OnCrash","arguments":[{"f":2.45}]}\u001e (server message)
            </div>
        </div>

        <div class="connection-panel">
            <h3>Connection Settings</h3>
            <div class="status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="connectionStatus">Disconnected</span>
            </div>
            
            <div class="input-group">
                <label for="wsUrl">WebSocket URL:</label>
                <input type="text" id="wsUrl" placeholder="wss://example.com/socket" value="">
            </div>
            
            <div class="input-group">
                <label for="accountId">Account ID (for hub invocation):</label>
                <input type="text" id="accountId" placeholder="123456789" value="">
            </div>
            
            <div class="button-group">
                <button id="connectBtn" class="connect-btn" onclick="toggleConnection()">Connect</button>
                <button class="test-btn" onclick="testWithSampleData()">Test with Sample Data</button>
                <button class="clear-btn" onclick="clearLog()">Clear Log</button>
            </div>
        </div>

        <div class="data-panel">
            <h3>Live Data</h3>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Messages Received</div>
                    <div class="stat-value" id="messagesReceived">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Last Crash Value</div>
                    <div class="stat-value" id="lastCrashValue">--</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Connection Time</div>
                    <div class="stat-value" id="connectionTime">--</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Frames Processed</div>
                    <div class="stat-value" id="framesProcessed">0</div>
                </div>
            </div>

            <div class="crash-history">
                <h4>Recent Crash History:</h4>
                <div class="crash-values" id="crashHistory">
                    <span style="color: #666; font-style: italic;">No crash values received yet</span>
                </div>
            </div>
        </div>

        <div class="data-panel">
            <h3>Protocol Log</h3>
            <div class="log-container" id="log"></div>
        </div>
    </div>

    <script>
        class SignalRWebSocketDemo {
            constructor() {
                this.websocket = null;
                this.messagesReceived = 0;
                this.framesProcessed = 0;
                this.connectionStartTime = null;
                this.connectionTimeInterval = null;
                this.crashHistory = [];
                
                this.log('Demo initialized - Ready to connect', 'info');
            }

            connect() {
                const url = document.getElementById('wsUrl').value.trim();
                const accountId = document.getElementById('accountId').value.trim();
                
                if (!url) {
                    this.log('Please enter a WebSocket URL', 'error');
                    return;
                }

                this.log(`Connecting to ${url}...`, 'info');
                this.updateConnectionStatus('connecting');

                try {
                    this.websocket = new WebSocket(url);

                    this.websocket.onopen = () => {
                        this.connectionStartTime = new Date();
                        this.updateConnectionStatus('connected');
                        this.log('WebSocket connected successfully', 'success');
                        this.startConnectionTimer();

                        // Send SignalR handshake
                        this.sendHandshake();
                        
                        // Send account subscription if account ID provided
                        if (accountId) {
                            setTimeout(() => this.sendAccountSubscription(accountId), 100);
                        }
                    };

                    this.websocket.onmessage = (event) => {
                        this.handleMessage(event.data);
                    };

                    this.websocket.onclose = (event) => {
                        this.updateConnectionStatus('disconnected');
                        this.log(`Connection closed (Code: ${event.code})`, 'warning');
                        this.stopConnectionTimer();
                    };

                    this.websocket.onerror = (error) => {
                        this.log('WebSocket error occurred', 'error');
                        this.updateConnectionStatus('disconnected');
                    };

                } catch (error) {
                    this.log(`Failed to connect: ${error.message}`, 'error');
                    this.updateConnectionStatus('disconnected');
                }
            }

            disconnect() {
                if (this.websocket) {
                    this.websocket.close();
                    this.websocket = null;
                    this.log('Disconnected by user', 'info');
                    this.stopConnectionTimer();
                }
            }

            sendHandshake() {
                const handshake = { protocol: "json", version: 1 };
                const message = JSON.stringify(handshake) + "\u001e";
                this.websocket.send(message);
                this.log('Sent handshake: ' + JSON.stringify(handshake), 'info');
            }

            sendAccountSubscription(accountId) {
                const subscription = {
                    arguments: [{ activity: 30, account: parseInt(accountId) }],
                    invocationId: "1",
                    target: "Account",
                    type: 1
                };
                const message = JSON.stringify(subscription) + "\u001e";
                this.websocket.send(message);
                this.log('Sent account subscription: ' + JSON.stringify(subscription), 'info');
            }

            handleMessage(data) {
                this.messagesReceived++;
                document.getElementById('messagesReceived').textContent = this.messagesReceived;

                // Split frames by \u001e delimiter
                const frames = data.split("\u001e").filter(f => f.trim().length > 0);
                
                this.log(`Received ${frames.length} frame(s) in message`, 'info');

                for (const frame of frames) {
                    this.processFrame(frame);
                }
            }

            processFrame(frame) {
                this.framesProcessed++;
                document.getElementById('framesProcessed').textContent = this.framesProcessed;

                try {
                    // Handle empty frames (common with SignalR)
                    if (!frame.trim()) {
                        this.log('Empty frame (keepalive)', 'info');
                        return;
                    }

                    // Try to parse as JSON
                    const message = JSON.parse(frame);
                    this.log(`Frame parsed: ${JSON.stringify(message)}`, 'info');

                    // Handle different message types
                    this.handleSignalRMessage(message);

                } catch (error) {
                    // Handle non-JSON frames
                    this.log(`Non-JSON frame: "${frame}"`, 'warning');
                }
            }

            handleSignalRMessage(message) {
                // Handle different SignalR message types
                switch (message.type) {
                    case 1: // Invocation
                        this.handleInvocation(message);
                        break;
                    case 2: // StreamItem
                        this.log('Stream item received', 'info');
                        break;
                    case 3: // Completion
                        this.log('Completion message received', 'success');
                        break;
                    case 6: // Ping
                        this.log('Ping received', 'info');
                        break;
                    case 7: // Close
                        this.log('Close message received', 'warning');
                        break;
                    default:
                        if (message.target) {
                            this.handleInvocation(message);
                        } else {
                            this.log(`Unknown message type: ${message.type}`, 'warning');
                        }
                }
            }

            handleInvocation(message) {
                const target = message.target;
                const args = message.arguments || [];

                this.log(`Invocation: ${target}`, 'success');

                switch (target) {
                    case 'OnCrash':
                        this.handleOnCrash(args);
                        break;
                    case 'OnRegistration':
                        this.handleOnRegistration(args);
                        break;
                    case 'OnBets':
                        this.log('Betting data received', 'info');
                        break;
                    default:
                        this.log(`Unknown target: ${target}`, 'info');
                }
            }

            handleOnCrash(args) {
                if (args.length > 0 && args[0].f !== undefined) {
                    const crashValue = args[0].f;
                    this.log(`CRASH VALUE: ${crashValue}`, 'crash');
                    
                    // Update display
                    document.getElementById('lastCrashValue').textContent = crashValue.toFixed(2);
                    
                    // Add to history
                    this.addToCrashHistory(crashValue);
                } else {
                    this.log('OnCrash received but no crash value found', 'warning');
                }
            }

            handleOnRegistration(args) {
                if (args.length > 0 && args[0].fs) {
                    const historyValues = args[0].fs;
                    this.log(`REGISTRATION HISTORY: ${historyValues.length} values`, 'history');
                    
                    historyValues.forEach((entry, index) => {
                        if (entry.f !== undefined) {
                            this.log(`History[${index}]: ${entry.f}`, 'history');
                            this.addToCrashHistory(entry.f);
                        }
                    });
                } else {
                    this.log('OnRegistration received but no history found', 'warning');
                }
            }

            addToCrashHistory(value) {
                this.crashHistory.unshift(value);
                
                // Keep only last 20 values
                if (this.crashHistory.length > 20) {
                    this.crashHistory = this.crashHistory.slice(0, 20);
                }
                
                this.updateCrashHistoryDisplay();
            }

            updateCrashHistoryDisplay() {
                const container = document.getElementById('crashHistory');
                
                if (this.crashHistory.length === 0) {
                    container.innerHTML = '<span style="color: #666; font-style: italic;">No crash values received yet</span>';
                    return;
                }
                
                container.innerHTML = this.crashHistory
                    .map(value => `<span class="crash-value">${value.toFixed(2)}</span>`)
                    .join('');
            }

            updateConnectionStatus(status) {
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('connectionStatus');
                const connectBtn = document.getElementById('connectBtn');

                indicator.className = `status-indicator ${status}`;
                
                switch (status) {
                    case 'connected':
                        statusText.textContent = 'Connected';
                        connectBtn.textContent = 'Disconnect';
                        connectBtn.className = 'connect-btn disconnect';
                        break;
                    case 'connecting':
                        statusText.textContent = 'Connecting...';
                        connectBtn.textContent = 'Connecting...';
                        connectBtn.disabled = true;
                        break;
                    default:
                        statusText.textContent = 'Disconnected';
                        connectBtn.textContent = 'Connect';
                        connectBtn.className = 'connect-btn';
                        connectBtn.disabled = false;
                }
            }

            startConnectionTimer() {
                this.connectionTimeInterval = setInterval(() => {
                    if (this.connectionStartTime) {
                        const elapsed = new Date() - this.connectionStartTime;
                        const minutes = Math.floor(elapsed / 60000);
                        const seconds = Math.floor((elapsed % 60000) / 1000);
                        document.getElementById('connectionTime').textContent = 
                            `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            }

            stopConnectionTimer() {
                if (this.connectionTimeInterval) {
                    clearInterval(this.connectionTimeInterval);
                    this.connectionTimeInterval = null;
                    document.getElementById('connectionTime').textContent = '--';
                }
            }

            log(message, type = 'info') {
                const logContainer = document.getElementById('log');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                
                const timestamp = new Date().toLocaleTimeString();
                entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
                
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Keep only last 100 entries for performance
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }

            testWithSampleData() {
                this.log('Testing with sample SignalR data...', 'info');
                
                // Sample frames as they would come from a real SignalR connection
                const sampleFrames = [
                    // Handshake response
                    '{}',
                    // OnRegistration with history
                    '{"type":1,"target":"OnRegistration","arguments":[{"fs":[{"f":2.45},{"f":1.67},{"f":3.21},{"f":1.23},{"f":5.67}]}]}',
                    // Individual crash events
                    '{"type":1,"target":"OnCrash","arguments":[{"f":2.89}]}',
                    '{"type":1,"target":"OnCrash","arguments":[{"f":1.45}]}',
                    '{"type":1,"target":"OnCrash","arguments":[{"f":7.23}]}',
                    // Ping
                    '{"type":6}'
                ];

                let delay = 0;
                sampleFrames.forEach((frame, index) => {
                    setTimeout(() => {
                        this.log(`Processing sample frame ${index + 1}/${sampleFrames.length}`, 'info');
                        this.processFrame(frame);
                    }, delay);
                    delay += 500;
                });
            }

            clearLog() {
                document.getElementById('log').innerHTML = '';
                this.log('Log cleared', 'info');
            }
        }

        // Global instance
        let demo;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            demo = new SignalRWebSocketDemo();
        });

        // Connection toggle function
        function toggleConnection() {
            if (demo.websocket && demo.websocket.readyState === WebSocket.OPEN) {
                demo.disconnect();
            } else {
                demo.connect();
            }
        }

        // Test function
        function testWithSampleData() {
            demo.testWithSampleData();
        }

        // Clear log function
        function clearLog() {
            demo.clearLog();
        }
    </script>
</body>
</html>
